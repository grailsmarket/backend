---
title: "Name Resolution"
description: "Resolving placeholder names to actual ENS names via The Graph"
order: 4
---

import Callout from '../../components/Callout.astro';
import CodeBlock from '../../components/CodeBlock.astro';

# Name Resolution

The Indexer resolves placeholder names (`token-{id}`) to actual ENS names using The Graph ENS subgraph.

## The Problem

OpenSea events often include token IDs instead of actual names:

<CodeBlock title="Placeholder name example">
```json
{
  "item": {
    "nft_id": "ethereum/0x57f1887a.../79233663829379634837589865448569342784712482819484549289560981379859480642508",
    "metadata": {
      "name": "token-79233663829379634837589865448569342784712482819484549289560981379859480642508"
    }
  }
}
```
</CodeBlock>

We need to resolve this to the actual ENS name (e.g., `vitalik.eth`).

## The Graph ENS Subgraph

The Graph provides a decentralized indexing protocol for blockchain data, including a comprehensive ENS subgraph.

### Endpoint

```
https://api.thegraph.com/subgraphs/name/ensdomains/ens
```

### Query Structure

<CodeBlock title="GraphQL query to resolve name">
```graphql
query GetENSName($tokenId: ID!) {
  domain(id: $tokenId) {
    id
    name
    labelName
    labelhash
    owner {
      id
    }
    resolver {
      id
    }
    registrant {
      id
    }
    expiryDate
  }
}
```
</CodeBlock>

## Resolution Strategy

### Token ID to Node Hash

ENS uses different identifiers:

<CodeBlock title="Identifier types">
```
Token ID (uint256):
79233663829379634837589865448569342784712482819484549289560981379859480642508

Label Hash (bytes32):
0xaf2caa1c2ca1d027f1ac823b529d0a67cd144264b2789fa2ea4d63a67c7103cc

Namehash (bytes32):
0xee6c4522aab0003e8d14cd40a6af439055fd2577951148c14b6cea9a53475835
```
</CodeBlock>

**Conversion:**

<CodeBlock title="Token ID to namehash">
```typescript
import { ethers } from 'ethers';
import { namehash } from '@ensdomains/ensjs';

function tokenIdToNamehash(tokenId: string): string {
  // Token ID is the label hash
  const labelHash = '0x' + BigInt(tokenId).toString(16).padStart(64, '0');

  // Compute namehash for .eth 2LD
  // namehash(name.eth) = keccak256(namehash('eth'), labelHash)
  const ethNode = namehash('eth'); // 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae

  return ethers.solidityPackedKeccak256(
    ['bytes32', 'bytes32'],
    [ethNode, labelHash]
  );
}
```
</CodeBlock>

### Query The Graph

<CodeBlock title="Resolve name from token ID">
```typescript
async function resolveNameFromGraph(tokenId: string): Promise<string | null> {
  const nodeHash = tokenIdToNamehash(tokenId);

  const query = `
    query {
      domain(id: "${nodeHash}") {
        name
        labelName
      }
    }
  `;

  const response = await fetch(process.env.GRAPH_ENS_SUBGRAPH_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ query })
  });

  const data = await response.json();

  if (data.data?.domain?.name) {
    return data.data.domain.name;
  }

  return null; // Name not found
}
```
</CodeBlock>

### Conditional Update

<Callout type="warning" title="Preserve Resolved Names">
Only update the database if the current name is a placeholder. Never overwrite actual names with placeholders.
</Callout>

<CodeBlock title="Conditional name update">
```typescript
await prisma.ens_names.upsert({
  where: { token_id: tokenId },
  update: {
    name: prisma.sql`
      CASE
        WHEN name LIKE 'token-%' THEN ${resolvedName}
        ELSE name
      END
    `,
    label_name: prisma.sql`
      CASE
        WHEN label_name LIKE 'token-%' THEN ${labelName}
        ELSE label_name
      END
    `
  },
  create: {
    token_id: tokenId,
    name: resolvedName,
    label_name: labelName,
    // ...
  }
});
```
</CodeBlock>

## Batch Resolution

For efficiency, resolve multiple names in a single request.

<CodeBlock title="Batch GraphQL query">
```graphql
query GetMultipleNames($ids: [ID!]!) {
  domains(where: { id_in: $ids }) {
    id
    name
    labelName
  }
}
```
</CodeBlock>

<CodeBlock title="Batch resolution function">
```typescript
async function resolveBatchFromGraph(
  tokenIds: string[]
): Promise<Map<string, string>> {
  const nodeHashes = tokenIds.map(tokenIdToNamehash);

  const query = `
    query {
      domains(where: { id_in: ${JSON.stringify(nodeHashes)} }) {
        id
        name
        labelName
      }
    }
  `;

  const response = await fetch(process.env.GRAPH_ENS_SUBGRAPH_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ query })
  });

  const data = await response.json();

  // Map nodeHash back to tokenId and name
  const results = new Map<string, string>();

  for (const domain of data.data.domains) {
    const tokenId = findTokenIdForNodeHash(domain.id, tokenIds);
    results.set(tokenId, domain.name);
  }

  return results;
}
```
</CodeBlock>

## Backfill Script

Resolve all placeholder names in the database.

<CodeBlock title="Backfill placeholder names">
```typescript
// services/indexer/src/scripts/backfill-ens-names.ts

async function backfillPlaceholderNames(limit: number = 1000) {
  // Find all placeholder names
  const placeholders = await prisma.ens_names.findMany({
    where: {
      name: {
        startsWith: 'token-'
      }
    },
    take: limit,
    select: {
      id: true,
      token_id: true,
      name: true,
    }
  });

  console.log(`Found ${placeholders.length} placeholder names`);

  // Process in batches of 100
  const BATCH_SIZE = 100;

  for (let i = 0; i < placeholders.length; i += BATCH_SIZE) {
    const batch = placeholders.slice(i, i + BATCH_SIZE);
    const tokenIds = batch.map(p => p.token_id);

    // Resolve via The Graph
    const resolved = await resolveBatchFromGraph(tokenIds);

    // Update database
    for (const placeholder of batch) {
      const resolvedName = resolved.get(placeholder.token_id);

      if (resolvedName) {
        await prisma.ens_names.update({
          where: { id: placeholder.id },
          data: {
            name: resolvedName,
            label_name: resolvedName.replace('.eth', ''),
          }
        });

        console.log(`Resolved: ${placeholder.name} -> ${resolvedName}`);
      } else {
        console.warn(`Could not resolve: ${placeholder.name}`);
      }
    }

    // Rate limiting
    await new Promise(resolve => setTimeout(resolve, 1000));
  }

  console.log('Backfill complete');
}

// Run with: node --loader tsx src/scripts/backfill-ens-names.ts
backfillPlaceholderNames(parseInt(process.argv[2]) || 1000);
```
</CodeBlock>

### Running the Script

<CodeBlock title="Execute backfill">
```bash
cd services/indexer

# Resolve 1000 placeholder names
node --loader tsx src/scripts/backfill-ens-names.ts 1000

# Resolve all placeholders (no limit)
node --loader tsx src/scripts/backfill-ens-names.ts 999999
```
</CodeBlock>

## Fallback Strategy

If The Graph is unavailable, fall back to direct blockchain queries.

<CodeBlock title="Blockchain fallback">
```typescript
import { ethers } from 'ethers';

async function resolveNameFromBlockchain(tokenId: string): Promise<string | null> {
  const provider = new ethers.JsonRpcProvider(process.env.ETHEREUM_RPC_URL);

  // ENS Registry contract
  const registryAddress = '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e';
  const registry = new ethers.Contract(
    registryAddress,
    ['function resolver(bytes32) view returns (address)'],
    provider
  );

  const nodeHash = tokenIdToNamehash(tokenId);

  try {
    const resolverAddress = await registry.resolver(nodeHash);

    if (resolverAddress === ethers.ZeroAddress) {
      return null; // No resolver set
    }

    // Query resolver for name
    const resolver = new ethers.Contract(
      resolverAddress,
      ['function name(bytes32) view returns (string)'],
      provider
    );

    const name = await resolver.name(nodeHash);
    return name || null;
  } catch (error) {
    console.error('Blockchain resolution failed:', error);
    return null;
  }
}
```
</CodeBlock>

<CodeBlock title="Primary + fallback resolution">
```typescript
async function resolveName(tokenId: string): Promise<string | null> {
  // Try The Graph first (faster)
  try {
    const name = await resolveNameFromGraph(tokenId);
    if (name) return name;
  } catch (error) {
    console.warn('The Graph resolution failed, trying blockchain...');
  }

  // Fall back to blockchain
  try {
    const name = await resolveNameFromBlockchain(tokenId);
    if (name) return name;
  } catch (error) {
    console.error('Blockchain resolution failed:', error);
  }

  return null;
}
```
</CodeBlock>

## Monitoring

### Check Placeholder Count

<CodeBlock title="Count unresolved names">
```sql
SELECT COUNT(*) as placeholder_count
FROM ens_names
WHERE name LIKE 'token-%';
```
</CodeBlock>

### Track Resolution Rate

<CodeBlock title="Resolution metrics">
```sql
-- Names resolved in last 24 hours
SELECT COUNT(*) as resolved_count
FROM ens_names
WHERE name NOT LIKE 'token-%'
  AND updated_at > NOW() - INTERVAL '24 hours'
  AND created_at < NOW() - INTERVAL '24 hours';

-- Resolution success rate
SELECT
  COUNT(CASE WHEN name NOT LIKE 'token-%' THEN 1 END) as resolved,
  COUNT(*) as total,
  ROUND(COUNT(CASE WHEN name NOT LIKE 'token-%' THEN 1 END)::numeric / COUNT(*) * 100, 2) as success_rate_pct
FROM ens_names
WHERE created_at > NOW() - INTERVAL '7 days';
```
</CodeBlock>

## Performance Considerations

### Rate Limiting

The Graph has rate limits:
- **Free tier**: ~1000 queries/day
- **Hosted service**: Higher limits
- **Decentralized network**: Pay per query

<Callout type="info" title="Rate Limit Strategy">
- Batch queries (up to 1000 domains per request)
- Cache results in database
- Add delay between requests (1 second)
- Use fallback to blockchain if rate limited
</Callout>

### Caching

<CodeBlock title="Cache resolved names">
```typescript
const nameCache = new Map<string, string>();

async function resolveNameCached(tokenId: string): Promise<string | null> {
  // Check cache first
  if (nameCache.has(tokenId)) {
    return nameCache.get(tokenId)!;
  }

  // Resolve and cache
  const name = await resolveName(tokenId);

  if (name) {
    nameCache.set(tokenId, name);
  }

  return name;
}
```
</CodeBlock>

## Configuration

### Environment Variables

```env
# The Graph
GRAPH_ENS_SUBGRAPH_URL=https://api.thegraph.com/subgraphs/name/ensdomains/ens
GRAPH_API_KEY=optional_api_key_for_higher_limits

# Fallback
ETHEREUM_RPC_URL=https://eth-mainnet.alchemyapi.io/v2/your-key
ENS_REGISTRY_ADDRESS=0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e

# Rate Limiting
GRAPH_REQUEST_DELAY=1000  # milliseconds between requests
GRAPH_BATCH_SIZE=100      # domains per batch
```

## Troubleshooting

### Names Not Resolving

**Symptoms:**
- Placeholder names remain in database
- The Graph queries return null

**Solutions:**
1. Verify `GRAPH_ENS_SUBGRAPH_URL` is accessible
2. Check token ID is valid (not expired or invalid name)
3. Try blockchain fallback
4. Verify namehash calculation is correct

### Rate Limit Errors

**Symptoms:**
- `429 Too Many Requests` errors
- Queries timing out

**Solutions:**
1. Increase `GRAPH_REQUEST_DELAY`
2. Reduce `GRAPH_BATCH_SIZE`
3. Get The Graph API key for higher limits
4. Use decentralized Graph Network
5. Fall back to blockchain queries

### Incorrect Name Resolution

**Symptoms:**
- Wrong name returned for token ID
- Names don't match blockchain data

**Solutions:**
1. Verify namehash calculation
2. Check The Graph subgraph is up to date
3. Compare with blockchain data directly
4. Report issue to The Graph if subgraph is wrong

## Next Steps

- Review [ENS event processing](/indexer/ens-events)
- Understand [OpenSea Stream integration](/indexer/opensea-stream)
- Learn about [WAL Listener](/wal-listener/overview)
